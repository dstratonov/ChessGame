using System.Collections.Generic;
using UnityEngine;

namespace Game.MovementTree
{
    /// <summary>
    /// A simple wrapper that associates an extra movement component with a target move number.
    /// Extra moves will only be applied to leaf nodes whose MoveNumber equals TargetMove.
    /// </summary>
    public class ExtraMovementEntry
    {
        public int TargetMove { get; private set; }
        public IMovementComponent Component { get; private set; }

        public ExtraMovementEntry(int targetMove, IMovementComponent component)
        {
            TargetMove = targetMove;
            Component = component;
        }
    }

    /// <summary>
    /// The movement tree. Its root node represents the starting position (0,0) in local space.
    /// </summary>
    public class MovementTree
    {
        public MovementNode Root { get; private set; }

        /// <summary>
        /// Extra move components that can be applied to the leaf nodes.
        /// Each extra move entry has a target move number; extra moves are only applied to leaves with that move number.
        /// </summary>
        public List<ExtraMovementEntry> ExtraMoveComponents { get; private set; }

        public MovementTree()
        {
            Root = new MovementNode(Vector2Int.zero, 0);
            ExtraMoveComponents = new List<ExtraMovementEntry>();
        }

        /// <summary>
        /// Adds movement edges to the tree by applying a movement component at all nodes
        /// that have MoveNumber equal to targetMove.
        /// For each such node, the component generates a list of new moves,
        /// which become children of that node. Their move number is set to (targetMove + 1).
        /// </summary>
        /// <param name="component">The movement component to add.</param>
        /// <param name="targetMove">
        /// The move number at which to apply the component.
        /// Use 0 to start from the root, 1 for nodes reached after one move, etc.
        /// </param>
        public void AddComponent(IMovementComponent component, int targetMove)
        {
            List<MovementNode> nodes = GetNodesAtMove(Root, targetMove);
            foreach (MovementNode node in nodes)
            {
                List<MovementNode> newNodes = component.GenerateMoves(node.LocalPosition);
                foreach (MovementNode child in newNodes)
                {
                    // Since this component represents a single move, we add 1.
                    child.MoveNumber = node.MoveNumber + 1;
                    node.Children.Add(child);
                }
            }
        }

        /// <summary>
        /// Recursively collects all nodes with MoveNumber equal to target.
        /// </summary>
        private List<MovementNode> GetNodesAtMove(MovementNode node, int target)
        {
            List<MovementNode> result = new List<MovementNode>();
            if (node.MoveNumber == target)
            {
                result.Add(node);
            }
            foreach (MovementNode child in node.Children)
            {
                result.AddRange(GetNodesAtMove(child, target));
            }
            return result;
        }

        /// <summary>
        /// Returns all reachable positions (relative to the starting position)
        /// by performing a DFS through the tree.
        /// </summary>
        public List<Vector2Int> GetAllReachablePositions()
        {
            List<Vector2Int> positions = new List<Vector2Int>();
            DFS(Root, positions);
            return positions;
        }

        private void DFS(MovementNode node, List<Vector2Int> positions)
        {
            positions.Add(node.LocalPosition);
            foreach (MovementNode child in node.Children)
            {
                DFS(child, positions);
            }
        }

        /// <summary>
        /// Returns all reachable positions (relative to the starting position) including
        /// extra moves generated by the ExtraMoveComponents on leaf nodes.
        /// Each extra move is only applied to leaves that have a matching target move.
        /// The original tree structure is not modified.
        /// </summary>
        public List<Vector2Int> GetAllReachablePositionsWithExtras()
        {
            // Get the positions from the original tree.
            List<Vector2Int> basePositions = GetAllReachablePositions();

            // Collect all leaf nodes (nodes with no children).
            List<MovementNode> leafNodes = new List<MovementNode>();
            GetLeafNodes(Root, leafNodes);

            // Use a set to avoid duplicate positions.
            HashSet<Vector2Int> allPositions = new HashSet<Vector2Int>(basePositions);

            // For each leaf, apply each extra move component that has a matching target move.
            foreach (MovementNode leaf in leafNodes)
            {
                foreach (ExtraMovementEntry extra in ExtraMoveComponents)
                {
                    if (leaf.MoveNumber == extra.TargetMove)
                    {
                        List<MovementNode> extraNodes = extra.Component.GenerateMoves(leaf.LocalPosition);
                        foreach (MovementNode extraNode in extraNodes)
                        {
                            allPositions.Add(extraNode.LocalPosition);
                        }
                    }
                }
            }

            return new List<Vector2Int>(allPositions);
        }

        /// <summary>
        /// Recursively collects all leaf nodes (nodes with no children) into the provided list.
        /// </summary>
        private void GetLeafNodes(MovementNode node, List<MovementNode> leaves)
        {
            if (node.Children.Count == 0)
            {
                leaves.Add(node);
            }
            else
            {
                foreach (MovementNode child in node.Children)
                {
                    GetLeafNodes(child, leaves);
                }
            }
        }
    }
}
